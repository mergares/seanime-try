{
  "id": "animeflv",
  "name": "AnimeFLV",
  "description": "AnimeFLV es un proveedor de streaming online para animes subtitulados en español (Latinoamérica)",
  "manifestURI": "",
  "version": "1.0.1",
  "author": "david",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "es-ES",
  "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\n// AnimeFLV provider implementation\n// Adapts the manifestex.json (AnimeSaturn) logic for animeflv.net\n// Language: Spanish (es-ES)\n\nclass Provider {\n    private baseUrl = \"https://www3.animeflv.net\";\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"AnimeFLV\"],\n            supportsDub: false, // AnimeFLV is mostly subbed\n            // @ts-ignore\n            supportedLanguages: [\"es-ES\"],\n        }\n    }\n\n    /**\n     * Search for anime on AnimeFLV\n     * @param query SearchOptions\n     * @returns Promise<SearchResult[]>\n     */\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n        // AnimeFLV search URL: /browse?q=QUERY\n        const searchUrl = `${this.baseUrl}/browse?q=${encodeURIComponent(query.query)}`;\n        const html = await this._makeRequest(searchUrl);\n        const $ = LoadDoc(html);\n        const results: SearchResult[] = [];\n\n        // Each anime result is in .Anime.alt.B\n        $(\".Anime.alt.B\").each((_, element) => {\n            const a = element.find(\"a\");\n            const url = a.attr(\"href\") || \"\";\n            const id = url.replace(\"/anime/\", \"\");\n            const title = a.text().trim();\n            results.push({\n                id: id,\n                title: title,\n                url: `${this.baseUrl}${url}` ,\n                subOrDub: \"sub\", // AnimeFLV is sub only\n            });\n        });\n        return results;\n    }\n\n    /**\n     * Get episodes for an anime\n     * @param id Anime ID (from search)\n     * @returns Promise<EpisodeDetails[]>\n     */\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        const animeUrl = `${this.baseUrl}/anime/${id}`;\n        const html = await this._makeRequest(animeUrl);\n        const $ = LoadDoc(html);\n        const episodes: EpisodeDetails[] = [];\n\n        // Episodes are in .ListCaps > li > a\n        $(\".ListCaps li\").each((_, element) => {\n            const a = element.find(\"a\");\n            const url = a.attr(\"href\") || \"\";\n            const epTitle = a.text().trim();\n            // Extract episode number from URL (e.g. /ver/one-piece-1124)\n            const match = url.match(/-(\\d+)$/);\n            const number = match ? parseInt(match[1], 10) : 0;\n            episodes.push({\n                id: url.replace(\"/ver/\", \"\"),\n                number: number,\n                url: `${this.baseUrl}${url}` ,\n                title: epTitle,\n            });\n        });\n        return episodes;\n    }\n\n    /**\n     * Get video sources for an episode\n     * @param episode EpisodeDetails\n     * @param _server string (ignored)\n     * @returns Promise<EpisodeServer>\n     */\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        const html = await this._makeRequest(episode.url);\n        const $ = LoadDoc(html);\n        const videoSources: VideoSource[] = [];\n        // Video sources are in #episode-page > script or in iframe\n        // For simplicity, extract the first iframe src\n        const iframe = $(\"iframe\").attr(\"src\") || \"\";\n        if (iframe) {\n            videoSources.push({\n                url: iframe.startsWith(\"http\") ? iframe : `https:${iframe}` ,\n                type: \"m3u8\", // Most AnimeFLV sources are HLS\n                quality: \"default\",\n                subtitles: [], // AnimeFLV is subbed in video\n            });\n        }\n        return {\n            server: \"AnimeFLV\",\n            headers: {},\n            videoSources,\n        };\n    }\n\n    /**\n     * Helper to fetch HTML with headers\n     */\n    private async _makeRequest(url: string): Promise<string> {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'text/html; charset=utf-8',\n                'User-Agent':\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0',\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch: ${response.statusText}`);\n        }\n        return await response.text();\n    }\n}\n",
}
